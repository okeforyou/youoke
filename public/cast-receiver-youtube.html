<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YouOke Cast Receiver</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #player {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
    }

    #status {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 25px;
      border-radius: 10px;
      font-size: 18px;
      z-index: 100;
      display: none;
    }

    #queue-info {
      position: absolute;
      bottom: 20px;
      right: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 25px;
      border-radius: 10px;
      font-size: 16px;
      z-index: 100;
    }

    .fade-in {
      animation: fadeIn 0.5s;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="status">üé§ YouOke Cast Receiver</div>
  <div id="queue-info">Ready...</div>
  <div id="player"></div>

  <!-- Google Cast Receiver SDK -->
  <script src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>

  <!-- YouTube IFrame Player API -->
  <script src="https://www.youtube.com/iframe_api"></script>

  <script>
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();
    const CAST_NAMESPACE = 'urn:x-cast:com.youoke.cast';

    let ytPlayer = null;
    let currentVideoId = null;
    let videoQueue = []; // Array of {videoId, title}
    let currentIndex = 0;

    // Status display
    function showStatus(message, duration = 3000) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.style.display = 'block';
      setTimeout(() => {
        status.style.display = 'none';
      }, duration);
    }

    function updateQueueInfo() {
      const info = document.getElementById('queue-info');
      if (videoQueue.length > 0) {
        const currentVideo = videoQueue[currentIndex];
        const title = currentVideo?.title || 'Unknown';
        const truncatedTitle = title.length > 50 ? title.substring(0, 50) + '...' : title;
        info.innerHTML = `
          <div style="max-width: 400px;">
            <div style="font-size: 14px; color: #aaa; margin-bottom: 5px;">
              ‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ (${currentIndex + 1}/${videoQueue.length})
            </div>
            <div style="font-size: 18px; font-weight: bold;">
              üéµ ${truncatedTitle}
            </div>
          </div>
        `;
      } else {
        info.textContent = 'Ready...';
      }
    }

    // YouTube IFrame Player ready
    function onYouTubeIframeAPIReady() {
      console.log('‚úÖ YouTube IFrame API ready');

      ytPlayer = new YT.Player('player', {
        height: '100%',
        width: '100%',
        playerVars: {
          autoplay: 1,
          controls: 1,
          modestbranding: 1,
          rel: 0,
          fs: 1,
        },
        events: {
          onReady: onPlayerReady,
          onStateChange: onPlayerStateChange,
          onError: onPlayerError,
        }
      });
    }

    function onPlayerReady(event) {
      console.log('‚úÖ YouTube Player ready');
      showStatus('üé§ Ready to Cast');
    }

    function onPlayerStateChange(event) {
      console.log('Player state:', event.data);

      // YT.PlayerState.ENDED = 0
      if (event.data === 0) {
        console.log('‚úÖ Video ended, checking for next...');

        // Notify sender that video ended
        sendMessageToSender({
          type: 'VIDEO_ENDED',
          videoId: currentVideoId,
          nextIndex: currentIndex + 1,
        });

        playNext();
      }
    }

    function sendMessageToSender(message) {
      try {
        context.sendCustomMessage(CAST_NAMESPACE, undefined, message);
        console.log('üì§ Sent message to sender:', message);
      } catch (error) {
        console.error('‚ùå Error sending message to sender:', error);
      }
    }

    function onPlayerError(event) {
      console.error('‚ùå YouTube Player error:', event.data);
      showStatus('‚ùå Error playing video', 5000);
    }

    function playVideo(videoIdOrObject) {
      if (!ytPlayer || !ytPlayer.loadVideoById) {
        console.error('‚ùå YouTube Player not ready');
        return;
      }

      // Support both string videoId and video object {videoId, title}
      const videoId = typeof videoIdOrObject === 'string'
        ? videoIdOrObject
        : videoIdOrObject.videoId;

      console.log('üé¨ Playing video:', videoId);
      currentVideoId = videoId;

      ytPlayer.loadVideoById({
        videoId: videoId,
        startSeconds: 0,
      });

      showStatus('‚ñ∂Ô∏è Playing...');
      updateQueueInfo();
    }

    function playNext() {
      if (currentIndex + 1 < videoQueue.length) {
        currentIndex++;
        const nextVideo = videoQueue[currentIndex];
        console.log('‚è≠Ô∏è Playing next video:', nextVideo);
        playVideo(nextVideo.videoId);
      } else {
        console.log('üì≠ Queue finished');
        showStatus('‚úÖ Queue finished', 5000);
      }
    }

    // Custom message handler
    context.addCustomMessageListener('urn:x-cast:com.youoke.cast', (customEvent) => {
      console.log('üì® Received custom message:', customEvent.data);

      const data = customEvent.data;

      switch (data.type) {
        case 'LOAD_VIDEO':
          // Find video in existing queue
          const videoIndex = videoQueue.findIndex(v => v.videoId === data.videoId);

          if (videoIndex !== -1) {
            // Video found in queue - just change current index
            currentIndex = videoIndex;
            console.log('üéØ Playing video from queue at index:', currentIndex);
          } else {
            // Video not in queue - this shouldn't happen normally, but handle it
            console.warn('‚ö†Ô∏è Video not in queue, playing anyway');
          }

          playVideo(data.videoId);
          updateQueueInfo();
          break;

        case 'LOAD_QUEUE':
          videoQueue = data.videos || [];
          currentIndex = 0;
          console.log('üìã Loaded queue with', videoQueue.length, 'videos');
          if (videoQueue.length > 0) {
            playVideo(videoQueue[0].videoId);
          }
          updateQueueInfo();
          break;

        case 'UPDATE_QUEUE':
          // Update queue without changing current index/video
          videoQueue = data.videos || [];
          console.log('üìù Queue updated, keeping current video. Total:', videoQueue.length);
          updateQueueInfo();
          break;

        case 'PLAY':
          if (ytPlayer) ytPlayer.playVideo();
          break;

        case 'PAUSE':
          if (ytPlayer) ytPlayer.pauseVideo();
          break;

        case 'NEXT':
          playNext();
          break;

        default:
          console.log('Unknown message type:', data.type);
      }
    });

    // Intercept LOAD requests and extract YouTube video ID
    playerManager.setMessageInterceptor(
      cast.framework.messages.MessageType.LOAD,
      (loadRequestData) => {
        console.log('üì¶ Load request:', loadRequestData);

        // Extract video ID from YouTube URL
        const contentId = loadRequestData.media.contentId;
        const videoIdMatch = contentId.match(/[?&]v=([^&]+)/);

        if (videoIdMatch) {
          const videoId = videoIdMatch[1];
          const title = loadRequestData.media.metadata?.title || 'Unknown';
          console.log('üé¨ Extracted video ID:', videoId, 'Title:', title);

          videoQueue = [{videoId, title}];
          currentIndex = 0;
          playVideo(videoId);

          // Return null to prevent default media player
          return null;
        }

        return loadRequestData;
      }
    );

    // Start Cast Receiver
    const options = new cast.framework.CastReceiverOptions();
    options.disableIdleTimeout = true;

    context.start(options);
    console.log('‚úÖ Cast Receiver started');
    showStatus('üé§ YouOke Cast Receiver Ready', 3000);
  </script>
</body>
</html>
